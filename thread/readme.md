# 线程

> 会顺便说到一点进程, 毕竟是先有进程执行流才有线程.

## 概述
### 执行流
CPU眼中只有执行流, 即程序计数器(x86~cs:ip寄存器)中指令的动态流.

### 进程
一段程序进入内存后, 拥有自己的(地址空间、寄存器映像、栈)[上下文环境],
可以单独上CPU执行, 这段执行流称为进程.<br/>
其实在线程出现以前, 没有进程的概念, 就是执行流: 一段程序的动态执行.

### 线程
为了让进程获得更多的CPU运行时间, 避免阻塞, 将进程划分为更细的执行流->线程.<br/>
线程其实就是函数和执行某个函数的上下文. CPU通过调度线程完成某个进程的执行.<br/>
线程是没有自己的地址空间的, 同一个进程中的线程共享进程内的地址空间. <br/>
多线程可以让进程的执行"提速". <br/>

### 竞争
不同线程上CPU执行是竞争关系!

## 进程、线程的状态
进程的微观执行单元是线程, 操作系统根据进程的执行条件将进程执行划分为3个状态:

    运行态, 等待态, 就绪态

> 线程提速的原因, 阻塞线程被挂起, 但是总的进程还是运行态.
> 或者说? 操作系统挂起某个进程是挂起该进程的全部线程还是?
> 😄 需要看操作系统能不能看到这个线程,
> 也就是线程是在内核空间实现的还是在用户进程空间实现的!:)

归根结底: CPU中运行的执行流是线程, 状态描述的也是针对线程的, 所谓的进程状态,
这里的进程不过是单线程进程的简称.

进程、线程、状态, 都是为了方便操作系统管理而人为划分的(操作系统不也是人写的吗?),
计算机就是CPU指令的执行,
CPU看到的只是指令流(程序计数器: CS:IP)所存储指令的动态流向,
线程不过是一段代码段(一个指令流),
只不过这个线程需要依靠进程作为资源容器(地址空间)上下文执行, 反之,
进程依靠线程的竞争执行完成自己的程序任务.  <br/>
CPU是一脸懵逼的. <br/>

## 进程控制表: PCB
操作系统看到的进程就是PCB.! <br/>
PCB的结构(基础结构):

        PCB
    _____________
    | 寄存器映像 |
    | 栈 |
    | 栈指针 |
    | pid |
    | 进程状态 |
    | 优先级 |
    | 时间片 |
    | 页表 |
    | 打开的文件描述符 |
    | 父进程 |
    ==========>

+ 寄存器映像: 保存进程运行时的所有寄存器的值, 一般位于PCB表的顶部, 可以[上下滑动?]
    - 寄存器映像存储到内核栈中.
+ 栈: 指进程使用的0特权级下的内核栈(并不是指3特权级下的用户栈), 和进程相关的所有资源放在一起, 方便管理
+ 栈指针: 记录0级栈栈顶的位置, 借此找到进程或线程的"寄存器映像"
+ pid: 进程id, 进程的唯一标识
+ 进程状态: 决定了进程在哪个状态队列中, 能否上CPU运行
+ 优先级: 决定了进程调度的先后顺序
+ 时间片: 决定了进程上CPU运行的时间长短
+ 页表: [代表进程的地址空间?]
+ 打开的文件描述符:
+ 父进程:

-> 每个进程的PCB组成进程表: 操作系统通过操纵进程表调度进程.<br/>
-> PCB维护一个指向0级特权栈的栈指针, 而寄存器映像存储在内核栈中,
可以通过PCB维护的栈指针找到, 进程运行时所有寄存器的值存储在寄存器映像中.
寄存器映像一般位于PCB的顶端, 因为进程或线程被中断时, 处理器会从TSS获取内核栈指针, 这个指针指向的区域, 就是寄存器映像, 如果线程或进程不是被中断, 而是主动让出CPU, 那么此时内核栈指针指向的位置不一定是栈顶, 所以寄存器映像不一定在PCB顶部<br/>

## 实现线程的2种方式->内核或用户进程

                / 用户进程使用系统调用 -> 0特权级的内核空间实现 -> 可以运行在用户进程中, 也可以运行在内核空间中
    实现线程 -->
                \ 用户进程自己实现线程 -> 3特权级的用户空间实现 -> 只能运行在用户进程中.

### 对比
在用户空间实现线程, 用户进程进行线程调度就不需要系统调用,
用户进程也不用陷入内核, 不用执行进出内核栈的操作, 节省了一定时间.
但是用户进出需要写调度器(一般不用普通人自己写), 需要维护线程表.
而且操作系统并看不到用户线程, 他调度的只能是进程, 所以当某个用户线程阻塞的时候,
操作系统会挂起所有该进程的用户线程(因为他只能看到进程).
可见用户线程实现并不是一个好的做法.<br/>
在内核空间中实现线程, 所有的线程调度都是由操作系统负责,
而且操作系统维护线程表便可以看到线程, 这样就可以真正发挥线程的提速作用.
当然用户进程执行系统调用陷入内核会多出一点时间开销, 但是相比与线程提速,
这些时间开销就不算什么了. <br/>

## 在内核空间实现线程
